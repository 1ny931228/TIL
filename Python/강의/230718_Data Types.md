# Data Types

2023.07.18(화)

1.  collection  2. sequence / non-sequence [제일 많이 씀(실용성 높음)]  3. 형변환  4. 산술연산자

### Data Types

- 값(피연산자)의 종류와 그 값에 적용 가능한 연산과 동작을 결정하는 속성

​		타입에 따라서, 동작이 달라짐.



- 데이터 타입 분류

  * Numeric Types
  	int(정수), float(실수), complex(복소수)
  * Text Sequence Types
  	str(문자열)
  * Sequence Types : 나열이 되어있다. 
  	list, tuple, range
  * Non-sequence Types
  	set, dict
  * 기타
  	Boolean, None, Functions

  

- 데이터 타입이 필요한 이유

  - 값들의 구분하고, 어떻게 다뤄야 하는지를 알 수 있음

  - 요리 재료마다 특정한 도구가 필요하듯이 각 데이터 타입 값들도 각자에게 적합한 도구를 가짐->우리가 프로그래밍을 할때, 각자가 필요한 도구가 다름 (예) 여러가지 변수를 담아야할 때, 리스트 씀

  - 타입을 명시적으로 지정하면 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해할 수 있고. 잘못된 데이터 타입으로 인한 오류를 미리 예방

    

### Numeric Types(수치형 타입) 

#### Int(정수 자료형) : 정수를 표현하는 자료형(영, 음수, 양수)

- 진수표현(2,8,16진수 일때는 앞에 0b, 0o, 0x로 표현됨.)

  - 2진수(binary) : 0b 
  - 8진수(octal) : 0o
  - 16진수(hexadecimal) : 0x

```python
# 진법 병경 12를 이진법, 8진법, 16진법으로 바꿈
print(bin(12)) # 0b1100
print(oct(12)) # 0o14
print(hex(12)) # 0xc
```



#### Float(실수 자료형) 

- 실수(소수)를 표현하는 자료형

  

- 프로그래밍 언어에서 float는 실수에 대한 근삿값 

  0.1은 0.1이 아니라 아주 가까운 근사값을 표현한 것이다. 



- 유한 정밀도

  - 컴퓨터 메모리 용량이 한정돼 있고 한 숫자에 대해 저장하는 용량이 제한 됨

  - 0.66666666666666과 1.666666666667은 

    제한된 양의 메모리에 저장할 수 있는 2/3과 5/3에 가장 가까운 값 

    2/3의 소수점이 끝까지 나오지만, 가장 가까운 근사값에 멈춤

  

- 실수 연산 시 주의 사항
  - 컴퓨터는 2진수를 사용, 사람은 10진법을 사용
  - 이때 10진수 0.1은 2진수로 표현하면 0.000110011001100110011.. 같이 무한대로 반복
  - 컴퓨터는 무한대 숫자를 그대로 저장할 수 없어서(why. 메모리의 한계) 사람이 사용하는 10진법의 근사값만 표시
  - 0.1의 경우 3602879701896397 / 2 ** 55 이며 0.1에 가깝지만 정확히 동일하지는 않음
  - 이런 과정에서 예상치 못한 경과가 나타남
  - 이런 증상을 **Floating point rounding error**(부동소수점 에러)라고 함

  

- 실수 연산시 해결책 

  - 두 수의 차이가 매우 작은 작은 수보다 작은지를 확인하거나 math 모듈 활용

    #is로 붙은 함수는 True/False인것을 알 수 있다. 

``` python
a = 3.2 - 3.1
b = 1.2 - 1.1

print(a) # 0.10000000000000009
print(b) # 0.09999999999999987

# 1. 임의의 작은 수 활용
print(abs(a - b) <= 1e-10) # True

# 2. math 모듈 활용
import math
print(math.isclose(a, b)) # True
```



- 지수(제곱하는 횟수) 표현 방식

  - e 또는 E를 사용한 지수 표현

```python
#지수(wprhqgksms ghlttn) 표현 10^
print(314e-2) #3.14
print(314e2) #31400
```



### Sequence Type

- 여러 개의 값들을 순서대로 나열하여 저장하는 자료형 ex) str, list, tuple, range

  

- Sequence Types 특징

  - 순서(sequence) : 값들이 순서대로 저장(**정렬 X**)


  - 인덱싱(Indexing) : 각 값에 고유한 인덱스(번호. 0부터 시작, zero base index)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음 -> 순서가 있어 그 위치에 접근이 가능하다. 


  - 슬라이싱(Slicing) : 인덱스 범위를 조절해 부분적인 값을 추출할 수 있음 (예) 3번째부터 5번째까지 가져오고 싶다. 


  - 길이(Length) : len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음 -> 길이의 값은 요소의 갯수의 값이다. 


  - 반복(lteration) : 반복문을 사용하여 저장된 값들을 반복적으로 처리할 수 있음

    

#### str(문자열) 

- 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형  

  시퀀스의 변경이 불가한 자료는 불변형 자료형이라고 말한다. 

  한글자 한글자를 실로 묶어놨달고 해서 string   

  

- 문자열 표현
  - 문자열은 단일 문자나 여러 문자의 조합으로 이루어짐

  - 작은따옴표('') 또는 큰 따옴표("") 감싸서 표현 -> 하지만, 한가지 따옴표로 써야함

    

- 중첩 따옴표

  - 따옴표 안에 따옴표를 표현할 경우
    - 작은 따옴표가 들어 있는 경우는 큰 따옴표로 문자열 생성
    - 큰 따옴표가 들어 이:ㅆ는 경우는 작은 따옴표로 문자열 생성

```python
print('문자열 안에 "큰 따옴표"를 사용하려면 작은 따옴표로 묶는다.')
print("문자열 안에 '작은 따옴표'를 사용하려면 큰 따옴표로 묶는다.")
```



- Escape sequence
  - 역시래스 뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합

  - 파이썬의 일반적인 문법 규칙을 잠시 탈출한다는 의미 


| 예약 문자 | 내용(의미)  |
| :-------: | :---------: |
|    \n     |   줄 바꿈   |
|    \t     |     탭      |
|    \\     |  백슬래시   |
|    \'     | 작은 따옴표 |
|    \"     |  큰 따옴표  |

```python
print('철수야 \'안녕\'') # 철수야 '안녕'
print('이 다음은 엔터\n입니다.')
# 이 다음은 엔터
# 입니다.
```



##### String Interpolation (문자 삽입법)

- 문자열 내에 변수나 표현식을 삽입하는 방법

  

- F-string 
  - 문자열에 f 또는 F 접두어를 붙이고 표현식을 {expression}로 작성하여 문자열에 파이썬 표현식을 값을 삽입할 수 있음



```python
#f-string
bugs = 'roaches'
counts = 13
area = 'living room'
print(f'Debugging {bugs} {counts} {area}')

#f-string 응용
greeting = 'hi'
print(f'{greeting:>10}')
print(f'{greeting:^10}') 
print(f'{3.141592:.4f}') : 소수점 4자리까지 표현하겠다. 
```



##### Index

- 시퀀스 내의 값들에 대한 고유한 번호로, 각 값의 위치를 식별하는 데 사용되는 숫자 

  책에 쓰는 책갈피와 같다. 순서가 있는 친구들에게 다 씀



##### Slicing

- 스퀀스의 일부분을 선택하여 추출하는 작업 > 자른다, 자를 수 있다.

  시작 인덱스와 끝 인덱스를 지정하여 해당 범위의 값을 포함하는 새로운 시퀀스를 생성

```python
 my_str = 'hello'
 print(my_str[2:4]) ll
 print(my_str[:3]) hel
 print(my_str[3:]) lo
 print(my_str[0:5:2]) hlo (2칸씩 점프점프하면서 자르겠다.)
 print(my_str[::-1]) olleh ('-1'로 문자열을 뒤집는다.) 
```



##### 문자열은 불변 (변경 불가) 

- 문자열은 원본을 바꿀 수 없다. > 바꿀 수 없으니, 새로운 문자열을 만들어야 한다. 

  

#### list(리스트) 

- 여러 개의 값을 순서대로 저장하는 **변경 가능한** 시퀀스 자료형 

  제일 많이 쓰는 자료 구조

```txt
[선생님 설명]
리스트 "여러개를 담기 위한 자료구조"
a =[1,2,3] heap에 1과 2와 3이 아무데나 따로 들어간다.  
유연성이 높다

배열 a =[1,2,3] heap에 1,2,3 순서대로 들어간다.
안정성과 예상성이 높다

파이선은 리스트만 있다.
```



##### 리스트 표현

- 리스트안에 모든 타입은 데이터가 들어갈수 있음

- 0개 이상의 객체를 포함하며 데이터 목록을 저장

- 대괄호([])로 표기

- 데이터는 어떤 자료형도 저장할 수 있음


```python
my_list_1 = []
my_list_2 = [1, 'a', 3, 'b', 5]
my_list_3 = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
```



##### 리스트의 시퀀스 특징

```python
my_list = [1, 'a', 3, 'b', 5]

# 인덱싱
print(my_list[1]) # a

# 슬라이싱
print(my_list[2:4]) # [3, 'b']
print(my_list[:3]) # [1, 'a', 3]
print(my_list[3:]) # ['b', 5]
print(my_list[0:5:2]) # [1, 3, 5]
print(my_list[::-1]) # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list)) # 5
```



##### 중첨된 리스트 접근

- 출력 값 예상해보기

```python
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]

print(len(my_list)) # 5
print(my_list[4][-1]) # !!!
print(my_list[-1][1][0]) # w
```



##### 리스트는 가변(변경 가능)

```python
my_list = [1, 2, 3]
my_list[0] = 100

print(my_list) # [100, 2, 3]
```



#### Tuple 

- 여러 개의 값을 순서대로 저장하는 **변경 불가능한** 시퀸스 자료형



##### 튜플 표현

- 0개 이상의 객체를 표함하며 데이터 목록을 저장 
- 소괄호(())로표기
- 데이터는 어떤한 자료형도 저장할 수 있음

```python
my_tuple_1 = ()
my_tuple_2 = (1,)
my_tuple_3 = (1, 'a', 3, 'b', 5)
```

```python
my_tuple = (1,)
# 만약 콤마가 없으면, (1)로 표기되며 파이썬이 연산에 1로 인식하기 때문에 콤마가 있어야한다. 
```



##### 튜플의 시퀀스 특징

```python
my_tuple = (1, 'a', 3, 'b', 5)

# 인덱싱
print(my_tuple[1]) # a

# 슬라이싱
print(my_tuple[2:4]) # (3, 'b')
print(my_tuple[:3]) # (1, 'a', 3)
print(my_tuple[3:]) # ('b', 5)
print(my_tuple[0:5:2]) # (1, 3, 5)
print(my_tuple[::-1]) # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_list)) # 5
```



##### 튜플은 불변(변경 불가)

```python
my_tuple = (1, 'a', 3, 'b', 5)

# TypeError : 'tuple' object does not support item assginment
my_tuple[1] = 'z'
```



##### 튜플은 어디에 쓰일까?

- 알고리즘 문제 풀때, 쓸 일은 없음

- 튜플의 불변 특성을 사용한 안전하게 여러 개의 값을 전달, 그룹화, 다중 할당 등 **개발자가 직접 사용하기 보다 '파이썬 내부 동작'에서 주로 사용됨**



#### range 

- 연속된 정수 스퀀스 생성하는 변경 불가능한 자료형



##### range 표현

- range(n) : 0부터 n-1까지(why. 0때문에)의 숫자의 시퀀스
- range(n,m) : n부터 m-1까지의 숫자 시퀀스
- 주로 반복문과 함께 사용 예정

```python
my_range_1 = range(5)
my_range_2 = range(1, 10)

print(my_range_1) # range(0, 5)
print(my_range_2) # range(1, 10)

# 리스트로 형 변환 시 데이터 확인 가능

print(list(my_range_1)) # [0, 1, 2, 3, 4]
print(list(my_range_2)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```



### Non-Sequence Types

- 순서가 없다. index / slicing 불가능 , len은 가능

#### dict 

- key - value 쌍으로 이루어진 '순서'와 중복이 없는 **변경 가능한** 자료형 



##### 딕셔너리 표현

- key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range...)
- value는 모든 자료형 사용 가능
- 중괄호({})로 표기

```python
my_dict_1 = {}
my_dict_2 = {'key': 'value'}
my_dict_3 = {'apple': 12, 'list': [1, 2, 3]}

print(my_dict_1) # {}
print(my_dict_2) # {'key': 'value'}
print(my_dict_3) # {'apple': 12, 'list': [1, 2, 3]}
```



##### 딕셔너리 사용

- key를 통해 value에 접근
- key는 삭제는 가능하지만, 변경을 불가하다. 

```python
my_dict = {'apple': 12, 'list': [1, 2, 3]}

print(my_dict['apple']) # 12
print(my_dict['list']) # [1, 2, 3]

# 값 변경
my_dict['apple'] = 100
print(my_dict) # {'apple': 100, 'list': [1, 2, 3]}
```



#### set

- 순서와 중복이 없는 변경 가능한 자료형 / 순서가 존재하면, 인덱스가 되지만, set는 순서가 없다.



##### 세트 표현

- 수학에서의 집합과 동일한 연산 처리 가능
- 중괄호 ({})로 표기

```python
my_set_1 = set()
my_set_2 = {1, 2, 3}
my_set_3 = {1, 1, 1}

print(my_set_1) # set()
print(my_set_2) # {1, 2, 3}
print(my_set_3) # {1}
```



##### 세트의 집합 연산

```python
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2) # {1, 2}

# 교집합
print(my_set_1 & my_set_2) # {3} 
```



### Other Types

#### None 

- 파이썬에서 '값이 없음'을 표현하는 자료형-> 0과 다르다 0의 정수의 값이 있는 것이다!


```
none과 0 은 다르다. 파이션에서 값이 없다는 것은 none 밖에 없다.
```



##### None 표현

```python
variable = None
print(variable) # None
```



### Boolean

- 참과 거짓을 표현하는 자료형

- 비교 / 논리 연사의 평가 결과로 사용됨
- 주로 조건 / 반복문과 함께 사용 

```
t.
is_를 붙여라
is_log로 변수명을 만들면, F/T로 표현된다.
```



### Collection

- 여러 개의 항목 또는 요소를 담는 자료 구조 (예) str, list, tuple, set, dict



##### 컬렉션 정리

| 컬렉션 | 변경 가능 여부 | 정렬 여부 |
| :----: | :------------: | :-------: |
|  str   |       X        |     O     |
|  list  |       O        |     O     |
| tuple  |       X        |     O     |
|  set   |       O        |     X     |
|  dict  |       O        |     X     |



##### 불변과 가변의 차이

```python
#불변과 가변
my_str = 'hello'
my_str[0] = 'z'

my_list = [1, 2, 3]
my_list[0] = 100
print(my_list) #[100, 2, 3]
```



stack과 heap의 구조는 다르다. 

시퀀스 str, list, tuple, set  공통점 6가지 중에 인덱싱. 반복, 슬라이싱, 길이 순으로 중요/ 순서가 포인트

```
좋은 코드인지 고민하기 위해서는 무한대로 늘려봐라. 

-> a = [1, ...., 10000000]

"단, 정렬이 되어있음 "  55555555 찾을려면 어떻게 해야할가? 인덱싱

정렬이 안되어 있으면, 하나하나 비교해야한다.
```



### Type Conversion

```
t. 
명시적은 모든 프로그래밍에서 되지만, 암시적은 파이썬만 된다. 
자유로워서 좋지만, 고급으로 갈 수록 위험성이 높다. 
```



#### 암시적 형변환(Implicit Type Conversion) 

: 파이썬이 자동으로 형변환을 하는 것



##### 암시적 형변환 예시

- Boolean과 Numeric Type에서만 가능


```python
print(3 + 5.0) # 8.0
print(True + 3) # 4
print(True + False) # 1
```



#### 명시적 형변환(Explicit Type Conversion)

: 개발자가 직접 형변환을 하는 것 암시적 형변환이 아닌 경우를 모두 포함

- 명시적 형변환 예시
  - str -> integer : 형식에 맞는 숫자만 가능 ex)print(int('3.5'))
  
  - integer -> str : 모두 가능
  
    

### Operator

#### 연산자

##### 산술 연산자

| 기호 |     연산자      |
| :--: | :-------------: |
|  -   |    음수 부호    |
|  +   |      덧셈       |
|  -   |      뺄셈       |
|  *   |      곱셈       |
|  /   |     나눗셈      |
|  //  | 정수 나눗셈(몫) |
|  %   |     나머지      |
|  **  | 지수(거듭제곱)  |



##### 복합 연산자

- 연산과 할당이 함께 이뤄짐

| 기호 |         |            |
| :--: | :-----: | :--------: |
|  +=  | a += b  | a = a + b  |
|  -=  | a -= b  | a = a - b  |
|  *=  | a *= b  | a = a * b  |
|  /=  | a /= b  | a = a / b  |
| //=  | a //= b | a = a // b |
|  %=  | a %= b  | a = a % b  |
| **=  | a **= b | a = a ** b |



#### 비교 연산자

|  기호  |   내용    |
| :----: | :-------: |
|   <    |   미만    |
|   <=   |   이하    |
|   >    |   초과    |
|   >=   |   이상    |
|   ==   |   같음    |
|   !=   | 같지 않음 |
|   is   |   같음    |
| is not | 같지 않음 |

```
- ==는 동등성, is는 식별성 이부분이 제일 중요
- 2.0 is 2 false이다. 왜냐하면 주소가 다르기 때문이다. 

* SytaxWarning
==은 값을 비교하는 것이지만, is는 레퍼런스를 비교하기 때문
is 연산자는 되도록이면 None, True, False 등을 비교할 때 사용
```



##### is 비교 연산자

- 메모리 내에서 같은 객체를 참조하는 지 확인

- ==는 동등성(equality), is는 식별성(identity)

- 값을 비교하는 ==와 다름

  

#### 논리 연산자

| 기호 |  연산자  |                             내용                             |
| :--: | :------: | :----------------------------------------------------------: |
| and  |  논리곱  |  두 피연산자 모두 True인 경우에만 전체 표현식을 True로 평가  |
|  or  |  논리합  | 두 피연산자 중 하나라도 True인 경우 전체 표현식을 True로 평가 |
| not  | 논리부정 |                     단일 피연산자를 부정                     |

```
시험) 연산자이기때문에 양옆으로 피연산자가 옵니다. 피연산자가 T/F로 평가 A = T/F B = T/F 
 A and B  => A와B가 모두 Ture일 때, Ture를 받고 그외에는 다 false이다. 
 AorB = > A, B 둘 중에 하나만 Ture이면 A or B는 True이다.
 not A 
```



#### 단축평가

- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

```python
print(3 and 5) # 5
print(false and 5) # false
print(5 and false) # false
print(5 and 3) # 3

값이 있다는 것은 트루라는 것이다. 
and에서 첫번째 값이 false면 나는 뒤에꺼 안 본다.
첫번째 값이 있으면 나는 뒤에꺼 본다. 뒤에꺼가 false 무시, 값이 있으면 뒤에 값을 출력한다.뒤에 값이 0이면 0출력함

0 != false
```



##### 단축평가 동작

- and
  - 첫번째 피연산자가 False인 경우, 전체 표현식은 False로 결정 두번째 피연산자는 평가되지 않고 그 값이 무시
  
  - 첫번째 피연산자가 True인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정 두번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환
  
    
  
- or
  -  첫번째 피연산자가 True인 경우, 전체 표현식은 True로 결정. 두번째 피연산자는 평가되지 않고 그 값이 무시
  - 첫번째 피연산자가 False인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정 두번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환



##### 단축평가 이유 

- 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함 > 코드 최대한 조금 돌릴려고



#### 멤버십 연산자

- 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인

|  기호  | 내용                                                         |
| :----: | ------------------------------------------------------------ |
|   in   | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는 지를 확인  |
| not in | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는 지를 확인 |



#### 시퀀스형 연산자

- +와 *는 시퀀스 간 연산에서 산술 연산자일때와 다른 역할을 가짐

| 연산자 |    내용     |
| :----: | :---------: |
|   +    | 결합 연산자 |
|   *    | 반복 연산자 |

```python
print([1,2]+[3,4]) # [1,2,3,4]
print([1,2]*2) #[1, 2, 1, 2]
```

