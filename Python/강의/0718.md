# Data Types

1.  collection  2. sequence / non-sequence [제일 많이 씀(실용성 높음)]  3. 형변환  4. 산술연산자

### Data Types

#### **Data Types** 

: 값(피연산자)의 종류와 그 값에 적용 가능한 연산과 동작을 결정하는 속성

타입에 따라서, 동작이 달라짐.

- 데이터 타입 분류

  ```
  * Numeric Types
  	int(정수), float(실수). complex(복소수)
  * Text Sequence Types
  	str(문자열)
  * Sequence Types
  	list, tuple, range
  * Non-sequence Types
  	set, dict
  * 기타
  	Boolean, None, Functions
  ```

  

- 데이터 타입이 필요한 이유

  - 값들의 구분하고, 어떻게 다뤄야 하는지를 알 수 있음

  - 요리 재료마다 특정한 도구가 필요하듯이 각 데이터 타입 값들도 각자에게 적합한 도구를 가짐->우리가 프로그래밍을 할때, 각자가 필요한 도구가 다름 (예) 여러가지 변수를 담아야할 때, 리스트 씀

  - 타입을 명시적으로 지정하면 코드를 읽는 사람이 변수의 의도를 더 쉽게 이해할 수 있고. 잘못된 데이터 타입으로 인한 오류를 미리 예방

    

### Numeric Types(수치형 타입) 정수형/실수형/복소수(복소수는 안함)

#### **int**(정수 자료형) : 정수를 표현하는 자료형(영, 음수, 양수)

- 진수표현(2,8,16진수 일때는 앞에 0b, 0o, 0x로 표현됨.)

  - 2진수(binary) : 0b 


​		- 8진수(octal) : 0o

- 16진수(hexadecimal) : 0x

  ```
  # 진법 병경 12를 이진법, 8진법, 16진법으로 바꿈
  print(bin(12))
  print(oct(12))
  print(hex(12))
  ```


#### **float**(실수 자료형) 

- 실수(소수)를 표현하는 자료형

- 프로그래밍 언어에서 float는 실수에 대한 근삿값 -> 0.1은 0.1이 아니라 아주 가까운 근사값을 표현한 것이다. 



- 유한 정밀도

  - 컴퓨터 메모리 용량이 한정돼 있고 한 숫자에 대해 저장하는 용량이 제한 됨
  - 0.66666666666666과 1.666666666667은 제한된 양의 메모리에 저장할 수 있는 2/3과 5/3에 가장 가까운 값 -> 2/3의 소수점이 끝까지 나오지만, 가장 가까운 근사값에 멈춤

  

- 실수 연산 시 주의 사항
  - 컴퓨터는 2진수를 사용, 사람은 10진법을 사용
  - 이때 10진수 0.1은 2진수로 표현하면 0.000110011001100110011.. 같이 무한대로 반복
  - 컴퓨터는 무한대 숫자를 그대로 저장할 수 없어서(why. 메모리의 한계) 사람이 사용하는 10진법의 근사값만 표시
  - 0.1의 경우 3602879701896397 / 2 ** 55 이며 0.1에 가깝지만 정확히 동일하지는 않음
  - 이런 과정에서 예상치 못한 경과가 나타남
  - 이런 증상을 **Floating point rounding error**(부동소수점 에러)라고 함

  

- 실수 연산시 해결책 

  - 두 수의 차이가 매우 작은 작은 수보다 작은지를 확인하거나 math 모듈 활용

    #is로 붙은 함수는 True/False인것을 알 수 있다. 
    
    

- 지수(제곱하는 횟수) 표현 방식

  - e 또는 E를 사용한 지수 표현

    ```
    #지수(wprhqgksms ghlttn) 표현 10^
    print(314e-2) #3.14
    print(314e2) #31400
    ```

    

### Sequence Type

#### **Sequence Type** 

#### : 여러 개의 값들을 **순서대로 나열**하여 저장하는 자료형 

#### (예) str, list, tuple, range

- Sequence Types 특징
  - 순서(sequence) : 값들이 순서대로 저장(**정렬 X**)
  
  - 인덱싱(Indexing) : 각 값에 고유한 인덱스(번호. 0부터 시작, zero base index)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음 -> 순서가 있어 그 위치에 접근이 가능하다. 
  
  - 슬라이싱(Slicing) : 인덱스 범위를 조절해 부분적인 값을 추출할 수 있음 (예) 3번째부터 5번째까지 가져오고 싶다. 
  
  - 길이(Length) : len() 함수를 사용하여 저장된 값의 개수(길이)를 구할 수 있음 -> 길이의 값은 요소의 갯수의 값이다. 
  
  - 반복(lteration) : 반복문을 사용하여 저장된 값들을 반복적으로 처리할 수 있음
  
    

#### str(문자열) 

: 문자들의 순서가 있는 변경 불가능한 시퀀스 자료형 -> 시퀀스의 변경이 불가한 자료는 불변형 자료형이라고 말한다. // 한글자 한글자를 실로 묶어놨달고 해서 string // 시퀀스, 글자 변경이 불가하다.  

- 문자열 표현
  - 문자열은 단일 문자나 여러 문자의 조합으로 이루어짐
  - 작은따옴표('') 또는 큰 따옴표("") 감싸서 표현 -> 하지만, 한가지 따옴표로 써야함

- 중첩 따옴표

  - 따옴표 안에 따옴표를 표현할 경우

    ```
    print('문자열 안에 "큰 따옴표"를 사용하려면 작은 따옴표로 묶는다.')
    ```

- Escape sequence

  - 역시래스 뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합

  - 파이썬의 일반적인 문법 규칙을 잠시 탈출한다는 의미 

    

#### String Interpolation : 문자열 내에 변수나 표현식을 삽입하는 방법

- F-string : 문자열에 f 또는 F 접두어를 붙이고 표현식을 {expression}로 작성하여 문자열에 파이썬 표현식을 값을 삽입할 수 있음


```
#f-string
bugs = 'roaches'
counts = 13
area = 'living room'
print(f'Debugging {bugs} {counts} {area}')

#f-string 응용
greeting = 'hi'
print(f'{greeting:>10}')
print(f'{greeting:^10}') 
print(f'{3.141592:.4f}') : 소수점 4자리까지 표현하겠다. 
```



#### index 

: 시퀀스 내의 값들에 대한 고유한 번호로, 각 값의 위치를 식별하는 데 사용되는 숫자 / 책에 쓰는 책갈피와 같다. 순서가 있는 친구들에게 다 씀



#### slicing : 스퀀스의 일부분을 선택하여 추출하는 작업 -> 자른다. // 자를 수 있다.

```
 my_str = 'hello'
 print(my_str[2:4]) ll
 print(my_str[:3]) hel
 print(my_str[3:]) lo
 print(my_str[0:5:2]) hlo (2칸씩 점프점프하면서 자르겠다.)
 print(my_str[::-1]) olleh ('-1'로 문자열을 뒤집는다.) ** p40 중요 꼭 기억해라 **
```



문자열은 불변 (변경 불가) : 문자열은 원본을 바꿀 수 없다. -> 바꿀 수 없으니, 새로운 문자열을 만들어야 한다. 

#### list(리스트) 

#### : 여러 개의 값을 순서대로 저장하는 **변경 가능한** 시퀀스 자료형 // 제일 많이 쓰는 자료 구조

```리스트 
[선생님 설명]
리스트 "여러개를 담기 위한 자료구조"
a =[1,2,3] heap에 1과 2와 3이 아무데나 따로 들어간다.  
유연성이 높다

배열 a =[1,2,3] heap에 1,2,3 순서대로 들어간다.
안정성과 예상성이 높다

파이선은 리스트만 있다.
```



배열

- 리스트 표현-> 리스트안에 모든 타입은 데이터가 들어갈수 있음

  - 0개 이상의 객체를 포함하며 데이터 목록을 저장

  - 대괄호([])로 표기

  - 데이터는 어떤 자료형도 저장할 수 있음

    

```
#인덱싱
my_list_1 = []
#슬라이싱
```

- 중첨된 리스트 접근

  - 출력 값 예상해보기

    

```
my_list = [1,2,3, 'python', ['hello', 'world', '!!!']]

print(leg)
```

- 리스트는 가변(변경 가능)
- tuple : 여러 개의 값을 순서대로 저장하는 **변경 불가능한** 시퀸스 자료형
- 튜플 표현
  - 0개 이상의 객체를 표함하며 데이터 목록을 저장 
  - 소괄호(())로표기
  - 데이터는 어떤한 자료형도 저장할 수 있음

```
my_tuple = (1,)
만약 콤마가 없으면, (1)로 표기되며 파이썬이 연산에 1로 인식하기 때문에 콤마가 있어야한다. 
```

- 튜플은 어디에 쓰일까?->문제 풀때, 쓸 일은 없음
  - 튜플의 불변 특성을 사용한 안전하게 여러 개의 값을 전달, 그룹화, 다중 할당 등 **개발자가 직접 사용하기 보다 '파이썬 내부 동작'에서 주로 사용됨**

- range : 연속된 정수 스퀀스 생성하는 변경 불가능한 자료형

- range 표현

  - range(n) : 0부터 n-1까지(why. 0때문에)의 숫자의 시퀀스
  - range(n,m) : n부터 m-1까지의 숫자 시퀀스
  - 주로 반복문과 함께 사용 예정

  

  시퀀스 순서가 있다. / 인덱스, / 슬라이싱/ 반복, /  길이 측정가능

  가변형(list), 불변형(튜플, range)으로 나눔

### Non-Sequence Types

#### dict 

- key - value 쌍으로 이루어진 '순서'와 중복이 없는 **변경 가능한** 자료형 
- 딕셔너리 표현
  - key는 변경 불가능한 자료형만 사용 가능(str, int, float, tuple, range...)
  - value는 모든 자료형 사용 가능
  - 중괄호({})로 표기
  - 

- 딕셔너리 사용
  - key를 통해 value에 접근
  - key는 삭제는 가능하지만, 변경을 불가하다. 
  - 

#### set

- 순서와 중복이 없는 변경 가능한 자료형 / 순서가 존재하면, 인덱스가 되지만, set는 순서가 없다.
- 세트 표현
  - 수학에서의 집합과 동일한 연산 처리 가능
  - 중괄호 ({})로 표기

### Other Types

#### None 

- 파이썬에서 '값이 없음'을 표현하는 자료형-> 0과 다르다 0의 정수의 값이 있는 것이다!


```
시험) none과 0 은 다르다. 파이션에서 값이 없다는 것은 none 밖에 없다.
```



####  Boolean

- 비교 / 논리 연사의 평가 결과로 사용됨
- 주로 조건 / 반복문과 함께 사용 

```
t.
is_를 붙여라
is_log로 변수명을 만들면, F/T로 표현된다.
```



### Collection(collection의 특징으로 모으자!)

- 여러 개의 항목 또는 요소를 담는 자료 구조 (예) str, list, tuple. set, dict

- 컬렉션 정리

```
#불변과 가변
my_str = 'hello'
my_str[0] = 'z'

my_list = [1, 2, 3]
my_list[0] = 100
print(my_list) #[100, 2, 3]
```



stack과 heap의 구조는 다르다. 

시퀀스 str, list, tuple, set  공통점 6가지 중에 인덱싱. 반복, 슬라이싱, 길이 순으로 중요/ 순서가 포인트

변경 가능 str, tuple 변경 불가능 list, set

```
좋은 코드인지 고민하기 위해서는 무한대로 늘려봐라. 

-> a = [1, ...., 10000000]

"단, 정렬이 되어있음 "  55555555 찾을려면 어떻게 해야할가? 인덱싱

정렬이 안되어 있으면, 하나하나 비교해야한다.
```



논 시퀀스 dict

```
dic = {1:가다, 2:나다}
정렬이 안되어 있으면, key만 찾으면 된다.
```

#궁금점 heap과 stack이 다르다 뭐가 다른지 찾아보자



### Type Conversion

```
t. 명시적은 모든 프로그래밍에서 되지만, 암시적은 파이썬만 된다. 자유로워서 되는 데, 고급으로 갈 수록 위험성이 높다. 
```



#### 암시적 형변환(Implicit Type Conversion) 

: 파이썬이 자동으로 형변환을 하는 것

- Boolean과 Numeric Type에서만 가능

  

#### 명시적 형변환(Explicit Type Conversion)

: 개발자가 직접 형변환을 하는 것 암시적 형변환이 아닌 경우를 모두 포함

- 명시적 형변환 예시
  - str -> integer : 형식에 맞는 숫자만 가능 ex)print(int('3.5'))
  
  - integer -> str : 모두 가능
  
    

#### Operator



### 연산자

#### 산술 연산자

```
시험 나머지 기호 기억하지 그리고 -2**2 답 기얷하지
```



#### 복합 연산자

#### 비교 연산자

```
시험) 103페이지 기호보기 104페이지 중요
==는 동등성, is는 식별성 이부분이 제일 중요

2.0 is 2 false이다. 왜냐하면 주소가 다르기 때문이다. (단답식)
```

- is 비교 연산자\
  - 메모리 내에서 같은 객체를 참조하는 지 확인
  - ==는 동등성(equality), is는 식별성(identity)
  - 값을 비교하는 ==와 다름

#### 논리 연산자

```
시험) 연산자이기때문에 양옆으로 피연산자가 옵니다. 피연산자가 T/F로 평가 A = T/F B = T/F 
 A and B  => A와B가 모두 Ture일 때, Ture를 받고 그외에는 다 false이다. 
 AorB = > A, B 둘 중에 하나만 Ture이면 A or B는 True이다.
 not A 
```



#### 단축평가

```
시험에 나옴

print(3 and 5) # 5
print(false and 5) # false
print(5 and false) # false
print(5 and 3) # 3

값이 있다는 것은 트루라는 것이다. 
and에서 첫번째 값이 false면 나는 뒤에꺼 안 본다.
첫번째 값이 있으면 나는 뒤에꺼 본다. 뒤에꺼가 false 무시, 값이 있으면 뒤에 값을 출력한다.뒤에 값이 0이면 0출력함

0 != false

시험) p 112 문제 풀기
```

: 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작

- 단축평가 동작

  - and
    - 첫번째 피연산자가 False인 경우, 전체 표현식은 False로 결정 두번째 피연산자는 평가되지 않고 그 값이 무시
    - 첫번째 피연산자가 True인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정 두번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환

  - or
    -  첫번째 피연산자가 True인 경우, 전체 표현식은 True로 결정. 두번째 피연산자는 평가되지 않고 그 값이 무시
    - 첫번째 피연산자가 False인 경우, 전체 표현식의 결과는 두 번째 피연산자에 의해 결정 두번째 피연산자가 평가되고 그 결과가 전체 표현식의 결과로 반환

- 단축평가 이유 : 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함 / 코드 최대한 조금 돌릴려고



#### 멤버십 연산자

: 특정 값이 시퀀스나 다른 컬렉션에 속하는지 여부를 확인

in 왼쪽 피연산자가 오른쪽 피여산자의 시퀀스에 속하는지를 확인 



#### 시퀀스형 연산자

: +와 *는 시퀀스 간 연산에서 산술 연산자일때와 다른 역할을 가짐

print([1,2]+[3,4]) # [1,2,3,4]

print([1,2]*2) #[1, 2, 1, 2]



##### 연산자 우선순위

